# Java Concurrency in Practice

## 第一部分 基础知识
### 第二章 线程安全性
#### 2.1 什么是线程安全性
* 定义：当多个线程访问某个类时，不管运行时环境采用何种调度方式或者这些线程将如何交替执行，并且在主调代码中不需要任何额外的同步或协同，这个类都能表现出正确的行为，那么就称这个类是线程安全的。
* 无状态对象一定是线程安全的
#### 2.2 原子性

#####  2.2.1 静态条件

* 最常见的竞态条件就是 **先检查后执行**

##### 2.2.2 示例：延迟初始化中的静态条件

* 延迟初始化的目的是将对象的初始化操作推迟到实际被使用时才进行，同时要确保只被初始化一次。

##### 2.2.3 复合操作

* 假定有两个操作A和B，如果从执行A的线程来看，当另一个线程执行B时，要么将B全部执行完，要么完全不执行B，那么A和B对彼此来说是原子的。原子操作是指，对于访问同一个状态的所有操作（包括该操作本身）来说，这个操作是一个以原子方式执行的操作。
* 在实际情况中，应尽可能地使用现有的线程安全对象（例如AcomicLong）来管理类的状态。与非线程安全的对象相比，判断线程安全对象的可能状态及其状态转换情况要更为容易，从而也更容易维护和验证线程安全性。

#### 2.3 加锁机制

* 要保持状态的一致性，就需要在单个原子操作中更新所有相关的状态变量。

##### 2.3.1 内置锁

* synchronnized (lock) {}

##### 2.3.2 重入

* 继承问题 父类中方法也有关键字synchronnized

#### 2.4 用锁来保护状态

* 对于可能被多个线程同时访问的可变状态变量，在访问它时都需要持有同一个锁，在这种情况下，我们称状态变量是由这个锁保护的。
* 每个共享的和可变的变量都应该只由一个锁来保护，从而使维护人员知道是哪一个锁。
* 一种常见的加锁约定是，将所有的可变状态都封装在对象内部，并通过对象的内置锁对所有访问可变状态的代码路径进行同步，使得在该对象上不会发生并发访问。
* 对于每个包含多个变量的不变性条件，其中涉及的所有变量都需要由同一个锁来保护。

#### 2.5 活跃性与性能

* 通常，在简单性与性能之间存在着相互制约因素。当实现某个同步策略时，一定不要盲目地为了性能而牺牲简单性（这可能会破坏安全性）。
* 当执行时间较长的计算或者可能无法快速完成的操作时（例如，网络I/O或控制台I/O），一定不要持有锁。

### 第三章 对象的共享

#### 3.1 可见性

* 在没有同步的情况下，编译器、处理器以及运行时等都可能对操作的执行顺序进行一些意想不到的调整。在缺乏足够同步的多线程程序中，要想对内存操作的执行顺序进行判断，几乎无法得出正确的结论。

##### 3.1.1 失效数据

* 当读线程查看 变量 时，可能会得到一个已经失效的值。

##### 3.1.2 非原子的64位操作

* 当线程在没有同步的情况下读取变量时，可能会得到一个失效值，但至少这个值是由之前某个线程设置的值，而不是一个随机值。这种安全性保证也被称为最低安全性。
* 最低安全性适用于绝大多数变量，但是存在一个例外：非volatile类型的64位数值变量（long， double）

##### 3.1.3 加锁与可见性

* 为什么在访问某个共享且可变的变量时要求所有线程在同一个锁上同步，就是为了确保某个线程写入该变量的值对于其他线程来说都是可见的。
* 加锁的含义不仅仅局限于互斥行为，还包括内存可见性。为了确保所有线程都能看到共享变量的最新值，所有执行读操作或者写操作的线程都必须在同一个锁上同步。

##### 3.1.4 volatile变量

* 仅当volatile变量能简化代码的实现以及对同步策略的验证时，才应该使用他们。如果在验证正确性时需要对可见行进行复杂的判断，那么就不要使用volatile变量。volatile变量的正确使用方式包括：确保它们自身状态的可见性，确保它们所引用对象的状态的可见行，以及标识一些重要的程序生命周期事件的发生。（例如，初始化或关闭）
* 加锁机制既可以确保可见性又可以确保原子性，而volatile变量只能确保可见性。

#### 3.2 发布与溢出

* 发布一个对象的意思是指，使对象能够在当前作用域之外的代码中使用。
* 当某个不应该发布的对象被发布时，这种情况就被称为逸出。
* 使用封装的主要原因：封装能够使得对程序的正确性进行分析变得可能，并使得无意中破坏设计约束条件变得更难。
* 发布对象的方法：1、将对象的引用保存到一个公有的静态变量中，以便任何类和线程都能看见该对象。2、当发布某个对象时，可能会间接的发布其他对象。3、发布一个内部的类实例。
* 不要在构造过程中使this引用逸出。

#### 3.3 线程封闭

* Swing中大量使用了线程封闭技术
* JDBC使用了线程封闭技术

##### 3.3.1 Ad-hoc线程封闭

##### 3.3.2 栈封闭

##### 3.3.3 ThreadLocal类

#### 3.4 不变性

* 不可变对象一定是线程安全的。
* 当满足以下条件时，对象才是不可变的：对象创建后其状态就不能修改；对象的所有域都是final类型；对象是正确创建的（在对象的创建期间，this引用没有逸出）

##### 3.4.1 Final域

* 正如"除非需要更高的可见性，否则应将所有的域都声明为私有域"是一个良好的编程习惯，"除非需要某个域是可变的，否则应将其声明为final域"也是一个良好的编程习惯。

##### 3.4.2 示例：使用volatile类型来发布不可变对象

#### 3.5 安全发布

##### 3.5.1 不正确的发布：正确的对象被破坏

##### 3.5.2 不可变对象与初始化安全性

* 任何线程都可以在不需要额外同步的情况下安全地访问不可变对象，即使在发布这些对象时没有使用同步。

##### 3.5.3 安全发布的常用模式

* 要安全地发布一个对象，对象的引用以及对象的状态必须同时对其他线程可见。一个正确构造的对象可以通过以下方式来安全的发布：1、在静态初始化函数中初始化一个对象引用。2、将对象的引用保存到volatile类型的域或者AtomicReferance对象中。3、将对象的引用保存到某个正确构造对象的final类型域中。4、将对象的引用保存到一个由锁保护的域中。

##### 3.5.4 事实不可变对象

* 定义：如果对象从技术上来看是可变的，但其状态在发布后不会再改变。

##### 3.5.5 可变对象

* 对象的发布需求取决于它的可变性：不可变对象可以通过任意机制来发布；事实不可变对象必须通过安全方式来发布；可变对象必须通过安全方式来发布，并且必须是线程安全的或者由某个锁保护起来。

##### 3.5.6 安全的共享对象

* 在并发编程中使用和共享对象时，可以使用一些实用的策略，包括：1、线程封闭。线程封闭的对象只能由一个线程拥有，对象被封闭在该线程中，并且只能由这个线程修改。2、只读共享。在没有额外同步的情况下，共享的只读对象可以由多个线程并发访问，但任何线程都不能修改它。共享的只读对象包括不可变对象和事实不可变对象。3、线程安全共享。线程安全的对象在其内部实现同步，因此多个线程可以通过对象的公有接口来进行访问而不需要进一步的同步。4、保护对象。被保护的对象只能通过持有特定的锁来访问。保护对象包括封装在其他线程安全对象中的对象，以及已发布的并且由某个特定锁保护的对象。


